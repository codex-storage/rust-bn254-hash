
use ark_ff::{One, Zero};
use ark_bn254::Fr as F;

use crate::permutation::*;
use crate::dom_sep::*;
use crate::words::*;

//------------------------------------------------------------------------------

// hash of field elements with the `10*` padding stategy (rate=2, capacity=1)
pub fn sponge_felts_pad(xs: Vec<F>) -> F {
  let l: usize = xs.len();
  let m: usize = l / 2;
  let mut state: State = zero_state();
  state.z = domain_separator(2, 3, 254, 1, None);
  for i in 0..m {
    state.x += xs[2*i  ];
    state.y += xs[2*i+1];
    permute_inplace(&mut state);
  }
  if (l & 1) == 0 {
    // even
    state.x += F::one();
    state.y += F::zero();
    permute_inplace(&mut state);
  }
  else {
    // odd
    state.x += xs[2*m];
    state.y += F::one();
    permute_inplace(&mut state);
  }
  state.x  
}

//------------------------------------------------------------------------------

// hash of field elements without padding (rate=2, capacity=1)
pub fn sponge_felts_no_pad(xs: Vec<F>) -> F {
  let l: usize = xs.len();
  assert!( l > 0 , "calling a sponge without padding for an empty input is not allowed");
  let m: usize = l / 2;
  let mut state: State = zero_state();
  state.z = domain_separator(2, 3, 254, 255, Some(l) );
  for i in 0..m {
    state.x += xs[2*i  ];
    state.y += xs[2*i+1];
    permute_inplace(&mut state);
  }
  if (l & 1) == 0 {
    // even
  }
  else {
    // odd
    state.x += xs[2*m];
    permute_inplace(&mut state);
  }
  state.x  
}

//------------------------------------------------------------------------------

// hash of u64 elements with the `10*` padding stategy (rate=2, capacity=1)
pub fn sponge_u64_pad(input: Vec<u64>) -> F {
  let l: usize = input.len();
  let m: usize = l / 7;
  let mut state: State = zero_state();
  state.z = domain_separator(2, 3, 64, 1, None);

  for i in 0..m {
    let (a,b) = u64s_to_felts( input[7*i..7*(i+1)].try_into().unwrap() );
    state.x += a;
    state.y += b;
    permute_inplace(&mut state);
  }
  
  let r = l - 7*m;
  let mut ws: [u64; 7] = [0; 7];
  for i in 0..r { 
    ws[i] = input[7*m+i]; 
  }
  ws[r] = 1;
  
  let (a,b) = u64s_to_felts( ws );
  state.x += a;
  state.y += b;
  permute_inplace(&mut state);

  state.x  
}

//------------------------------------------------------------------------------

// hash of u64 elements with no padding (rate=2, capacity=1)
pub fn sponge_u64_no_pad(input: Vec<u64>) -> F {
  let l: usize = input.len();
  let m: usize = l / 7;
  let mut state: State = zero_state();
  state.z = domain_separator(2, 3, 64, 255, Some(l) );

  for i in 0..m {
    let (a,b) = u64s_to_felts( input[7*i..7*(i+1)].try_into().unwrap() );
    state.x += a;
    state.y += b;
    permute_inplace(&mut state);
  }
  
  let r = l - 7*m;
  if r > 0 {
    let mut ws: [u64; 7] = [0; 7];
    for i in 0..r { 
      ws[i] = input[7*m+i]; 
    }
    let (a,b) = u64s_to_felts( ws );
    state.x += a;
    state.y += b;
    permute_inplace(&mut state);
  }

  state.x  
}

//------------------------------------------------------------------------------

#[cfg(test)]
mod tests {
  use super::*;
  use ark_std::str::FromStr;

   #[test]
  fn sponge_felt_pad_kats() {
    let expected_results_rate2: [F; 9] =
      [ F::from_str("19499082269592267598445447545057958665614609297846978854367973542689225942769").unwrap()
      , F::from_str("18575012789231469229884764324941297325518518125159947154666143736134627612926").unwrap()
      , F::from_str("8497041170554791294461959662381834821683188757759653310126334787903454881833" ).unwrap()
      , F::from_str("7477361136953606818741895260704612015724121297282898803513690475311354933324" ).unwrap()
      , F::from_str("124468679175306239235509344657309567209200730228442938605071013597332255858"  ).unwrap()
      , F::from_str("16623067489256565233778087665060282683386099247772442960143578746217625299219").unwrap()
      , F::from_str("11486960019850145257815352297225482939271961443661416961989480881863168607026").unwrap()
      , F::from_str("20420541301992412878354329495337915388337723490334029715201499395107517967097").unwrap()
      , F::from_str("15368493599988308785714434050658408098972196808672741268698522157366881904768").unwrap()
      ];
    for n in 0..9 {
      let mut input: Vec<F> = vec![];
      for i in 0..n { 
        input.push( F::from( (i+1) as u64 ) ); 
      }
      // println!("{} -> {:?}",n,input);
      let hash = sponge_felts_pad(input);
      assert_eq!( hash, expected_results_rate2[n] );
    }
  }

  #[test]
  fn sponge_felt_no_pad_kats() {
    let expected_results_rate2: [F; 8] =
      [ F::from_str("1115918818644972208256556451100635122398669465847258748217648737442977805626" ).unwrap()
      , F::from_str("14606415634430706215884818096498881510473181807310833038459556078598593236816").unwrap()
      , F::from_str("9485615666040940930611140660524640705765583288508158728233312031857138670757" ).unwrap()
      , F::from_str("20401237157213398255038629506386304295305318378599525962978400077485609070796").unwrap()
      , F::from_str("20208871202210448689110666321197722246973630737484044507918809147933228726996").unwrap()
      , F::from_str("14938587838311406451824091859899313044072447315841015916269519874840159740247").unwrap()
      , F::from_str("11479043188138784663840472048316951506772440497204157038728405744356281950623").unwrap()
      , F::from_str("3006319728287530003674112915766568045278537432548373174348553115657244497387" ).unwrap()
      ];
    for n in 1..9 {
      let mut input: Vec<F> = vec![];
      for i in 0..n { 
        input.push( F::from( (i+1) as u64 ) ); 
      }
      // println!("{} -> {:?}",n,input);
      let hash = sponge_felts_no_pad(input);
      assert_eq!( hash, expected_results_rate2[n-1] );
    }
  }

  #[test]
  fn sponge_u64_pad_kats() {
    let expected_results: [F; 26] =
      [ F::from_str("17514399988141690447675586952929944437374386600212775525745235123193699555032").unwrap()
      , F::from_str("15124300392866129625907254960122795910205844155666063049200988935627203491787").unwrap()
      , F::from_str("13587423140487214521084491943587345128478209306845428025363074670465625624321").unwrap()
      , F::from_str("12103983798657775481823964499179295155327629253022862964673907271061250824264").unwrap()
      , F::from_str("20075738905477296762380600826668453184446891863732492542257921789538449731444").unwrap()
      , F::from_str("10430518105738464845312764067958560485227661670628084370392094650064674199658").unwrap()
      , F::from_str("20924108742969347294850424304102064711127764900339973953667556234138111787510").unwrap()
      , F::from_str("968395453138586552370198024505056859000725381881719123351113644983838200204"  ).unwrap()
      , F::from_str("8403856038018490204768039403731489540117870413556878458592547058003244926229" ).unwrap()
      , F::from_str("16773493555189025057417290550518127090656517836360451753303041522973049024060").unwrap()
      , F::from_str("10796069259852617377688296009811814682856359062681790205732483337367778154920").unwrap()
      , F::from_str("15397294020764383918470741938281032379900840831074050208355543125684530394430").unwrap()
      , F::from_str("1905594899844509263294014245146268960239215922806331766521984979753295643902" ).unwrap()
      , F::from_str("20876830728236138738089605017460220905713320987850603810408317778321908917363").unwrap()
      , F::from_str("10439676373152722304438465306359532293430592776273158404192767424975467653320").unwrap()
      , F::from_str("518205633402517040339835406058408206457599900552667860583791777499369334957"  ).unwrap()
      , F::from_str("8336177439429172243794598744828960640267423771354227970042733860391880997012" ).unwrap()
      , F::from_str("9080685064607669536173711033203229621291070088551220184449841720023355805200" ).unwrap()
      , F::from_str("17385687619795248602970166024979651801761808477798651323211402886029725219684").unwrap()
      , F::from_str("18417161975837058148399677934835298960723961827737851459880086777820548860759").unwrap()
      , F::from_str("19716747844776708500992610060411505612053548811334757970282709554641308624532").unwrap()
      , F::from_str("8710645140983242543147803248831658356923859186424675188947482917691397449924" ).unwrap()
      , F::from_str("20530027673279210141353437535216247451946999718955256941446828775858247330028").unwrap()
      , F::from_str("5828577664570014619333209283838642006612682022514780211751976484340560101018" ).unwrap()
      , F::from_str("11634491495286507638327689549013822249311934738903688618548429046204183053378").unwrap()
      , F::from_str("8807597179061926120642963333889680138583084849444686960463225056442107479985" ).unwrap()
      ];
    for n in 0..26 {
      let mut input: Vec<u64> = vec![];
      for i in 0..n { 
        input.push( (i+1) as u64 ); 
      }
      // println!("{} -> {:?}",n,input);
      let hash = sponge_u64_pad(input);
      assert_eq!( hash, expected_results[n] );
    }
  }

  #[test]
  fn sponge_u64_no_pad_kats() {
    let expected_results: [F; 25] =
      [ F::from_str("21622597924725733979495520095566570609749554956201434757717414014785749203159").unwrap()
      , F::from_str("15070262037465553878910423448919356460240312147417573379822098585639266186611").unwrap()
      , F::from_str("17800489455509024472491810131844528230790380101487728609977022937572918817580").unwrap()
      , F::from_str("18482544902001991994086264832152752194342835563028328345881200344807794769093").unwrap()
      , F::from_str("4896513280044258797056334181171313949942478968223215541746367832949335730719" ).unwrap()
      , F::from_str("10607466914319299071570865986536377097225307429856216127936317545081254434163").unwrap()
      , F::from_str("20920453842438987955159119036186533249700471511579581309756585632502753287950").unwrap()
      , F::from_str("10142584335678051072230022498141744715568278869207119228015367697171636332483").unwrap()
      , F::from_str("8127573586370924616640504816002170182366974095264816809743966109465196084712" ).unwrap()
      , F::from_str("20501115081171281094927237732262757083689925310922435884195895336705387283312").unwrap()
      , F::from_str("21718736237191095099244323827903849179538431290485808056798870455448217925093").unwrap()
      , F::from_str("5329770041250619031368715837636171331829813019969012081505727572188217732934" ).unwrap()
      , F::from_str("5536718914992748414523347895616925070211178854135748328150567266300552067485" ).unwrap()
      , F::from_str("2342299046320660948203954171575512853623883371738280507120380123090358747132" ).unwrap()
      , F::from_str("17453198006826074954036266521394818291071518114598196144854794710197222107246").unwrap()
      , F::from_str("21690412374475433925321578588113530111207813306323496795476840269069535072168").unwrap()
      , F::from_str("917342963235263089117027572485105782705895038326149594009829794659181334451"  ).unwrap()
      , F::from_str("814652782599295015685819882207503906021843279393495868703807596344336059332"  ).unwrap()
      , F::from_str("8618671375832156391944304266004989498789486790466471210906461400013981588954" ).unwrap()
      , F::from_str("20775280237828871312555473717074489898073475363933916673847313267274833513741").unwrap()
      , F::from_str("4959358925764805024322589850837173061872468998088908390781158651152414358200" ).unwrap()
      , F::from_str("6722516458366036816475139923425349719879460303424067286694084614694693662945" ).unwrap()
      , F::from_str("10918347824743901498913169606811754277556665472042558262426391959263833235902").unwrap()
      , F::from_str("1920831798438862469031092832500327049860677246669734790815791649814404269702" ).unwrap()
      , F::from_str("2950115377168425877897898851550119758110847105372644043990473657177484603663" ).unwrap()
      ];
    for n in 1..26 {
      let mut input: Vec<u64> = vec![];
      for i in 0..n { 
        input.push( (i+1) as u64 ); 
      }
      println!("{} -> {:?}",n,input);
      let hash = sponge_u64_no_pad(input);
      assert_eq!( hash, expected_results[n-1] );
    }
  }

}
